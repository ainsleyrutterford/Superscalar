; int r[280 + 1];
; int i, k;
; int b, d;
; int c = 0;

; for (i = 0; i < 280; i++) {
;   r[i] = 2000;
;   }

;   for (k = 280; k > 0; k -= 14) {
;   d = 0;
;   i = k;
;   while (1) {
;     d += r[i] * 10000;
;     b = 2 * i - 1;

;     r[i] = d % b;
;     d /= b;
;     i--;
;     if (i == 0) break;
;     d *= i;
;   }
;   printf("%d ", c + d / 10000);
;   c = d % 10000;
; }

; $0 = 0
; $1 = 1
; $2 = 2
; $3 = i
; $4 = k
; $5 = b
; $6 = d
; $15 = c
; $10 = j

.r: 2000 2000 2000 2000 2000 2000 2000 2000 2000 2000 2000 2000 2000 2000 2000 2000 2000 2000 2000 2000 2000 2000 2000 2000 2000 2000 2000 2000 2000 2000 2000 2000 2000 2000 2000 2000 2000 2000 2000 2000 2000 2000 2000 2000 2000 2000 2000 2000 2000 2000 2000 2000 2000 2000 2000 2000 2000 2000
.o: 0 0 0 0

    addi $1 $0 1       ; $1 = 1
    addi $2 $0 2       ; $2 = 2
    addi $4 $0 56      ; k = 56
    addi $8 $0 10000   ; $8 = 10000

for:
    addi $6 $0 0       ; d = 0
    addi $3 $4 0       ; i = k
while:
    lw $7 r($3)        ; $7 = r[i]
    imul $5 $2 $3      ; b = 2 * i
    sub $5 $5 $1       ; b = 2 * i - 1
    imul $9 $7 $8      ; $9 = r[i] * 10000
    add $6 $6 $9       ; d += r[i] * 10000
    mod $16 $6 $5      ; $16 = d % b
    sw r($3) $16       ; r[i] = d % b
    idiv $6 $6 $5      ; d = d / b
    sub $3 $3 $1       ; i--
    beq $3 $0 'break'  ; if (i == 0) break
    imul $6 $6 $3      ; d = d * i
    j 'while'
break:
    idiv $11 $6 $8     ; $11 = d / 10000
    add $11 $11 $15    ; $11 = c + d / 10000
    sw o($10) $11      ; o[j] = c + d / 10000
    add $10 $10 $1     ; j++
    mod $15 $6 $8      ; c = d % 10000
    subi $4 $4 14      ; k -= 14
    blt $0 $4 'for'    ; if (k > 0) for loop again

    addi $31 $31 1     ; set register 31 to 1 (halt)